{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;;;;ACDA;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzNA;AACA;AACA","sources":["../../../../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack/bootstrap","../webpack/runtime/compat","../external node-commonjs \"node:fs/promises\"",".././src/action.js",".././src/index.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:fs/promises\");","import core from '@actions/core';\nimport { LinkChecker, LinkState, getConfig } from 'linkinator';\nimport fs from 'node:fs/promises';\nimport axios from 'axios';\n\nexport async function getFullConfig () {\n  const defaults = {\n    path: ['*.md'],\n    concurrency: 100,\n    recurse: false,\n    skip: [],\n    timeout: 0,\n    markdown: true,\n    retry: false,\n    verbosity: 'WARNING'\n  };\n  // The options returned from `getInput` appear to always be strings.\n  const actionsConfig = {\n    path: parseList('paths'),\n    concurrency: parseNumber('concurrency'),\n    recurse: parseBoolean('recurse'),\n    skip: parseList('linksToSkip') || parseList('skip'),\n    timeout: parseNumber('timeout'),\n    markdown: parseBoolean('markdown'),\n    serverRoot: parseString('serverRoot'),\n    directoryListing: parseBoolean('directoryListing'),\n    retry: parseBoolean('retry'),\n    verbosity: parseString('verbosity'),\n    config: parseString('config')\n  };\n  const urlRewriteSearch = parseString('urlRewriteSearch');\n  const urlRewriteReplace = parseString('urlRewriteReplace');\n  actionsConfig.urlRewriteExpressions = [];\n  if (urlRewriteSearch && urlRewriteReplace) {\n    actionsConfig.urlRewriteExpressions.push(\n      {\n        pattern: urlRewriteSearch,\n        replacement: urlRewriteReplace\n      }\n    );\n  }\n  const fileConfig = await getConfig(actionsConfig);\n  const config = Object.assign({}, defaults, fileConfig);\n  config.linksToSkip = config.skip;\n  return config;\n}\n\nasync function validateSubscription () {\n  const API_URL = `https://agent.api.stepsecurity.io/v1/github/${process.env.GITHUB_REPOSITORY}/actions/subscription`;\n\n  try {\n    await axios.get(API_URL, { timeout: 3000 });\n  } catch (error) {\n    if (error.response && error.response.status === 403) {\n      console.error(\n        'Subscription is not valid. Reach out to support@stepsecurity.io'\n      );\n      process.exit(1);\n    } else {\n      core.info('Timeout or API not reachable. Continuing to next step.');\n    }\n  }\n}\n\nexport async function main () {\n  try {\n    await validateSubscription();\n    const config = await getFullConfig();\n    const verbosity = getVerbosity(config.verbosity);\n    const logger = new Logger(verbosity);\n    const { GITHUB_HEAD_REF, GITHUB_BASE_REF, GITHUB_REPOSITORY, GITHUB_EVENT_PATH } = process.env;\n    // Read pull_request payload and use it to determine head user/repo:\n    if (GITHUB_EVENT_PATH) {\n      try {\n        const payloadRaw = await fs.readFile(GITHUB_EVENT_PATH, 'utf8');\n        const payload = JSON.parse(payloadRaw);\n        if (payload?.pull_request?.head) {\n          const repo = payload.pull_request.head.repo.full_name;\n          core.info(`rewrite repo to ${repo}`);\n          if (!config.urlRewriteExpressions) {\n            config.urlRewriteExpressions = [];\n          }\n          config.urlRewriteExpressions.push({\n            pattern: new RegExp(`github.com/${GITHUB_REPOSITORY}(/.*/)(${GITHUB_BASE_REF})/(.*)`),\n            replacement: `github.com/${repo}$1${GITHUB_HEAD_REF}/$3`\n          });\n        }\n      } catch (err) {\n        core.warning(err);\n      }\n    }\n\n    const checker = new LinkChecker()\n      .on('link', link => {\n        switch (link.state) {\n          case LinkState.BROKEN:\n            logger.error(`[${link.status.toString()}] ${link.url}`);\n            break;\n          case LinkState.OK:\n            logger.warn(`[${link.status.toString()}] ${link.url}`);\n            break;\n          case LinkState.SKIPPED:\n            logger.info(`[SKP] ${link.url}`);\n            break;\n        }\n      })\n      .on('retry', retryInfo => {\n        logger.info('[RETRY]', retryInfo);\n      });\n    core.info(`Scanning ${config.path.join(', ')}`);\n    const result = await checker.check(config);\n    const nonSkippedLinks = result.links.filter(x => x.state !== 'SKIPPED');\n    core.info(`Scanned total of ${nonSkippedLinks.length} links!`);\n    if (!result.passed) {\n      const brokenLinks = result.links.filter(x => x.state === 'BROKEN');\n      let failureOutput = `Detected ${brokenLinks.length} broken links.`;\n\n      // build a map of failed links by the parent document\n      const parents = brokenLinks.reduce((acc, curr) => {\n        const parent = curr.parent || '';\n        if (!acc[parent]) {\n          acc[parent] = [];\n        }\n        acc[parent].push(curr);\n        return acc;\n      }, {});\n\n      for (const parent of Object.keys(parents)) {\n        failureOutput += `\\n ${parent}`;\n        for (const link of parents[parent]) {\n          failureOutput += `\\n   [${link.status}] ${link.url}`;\n          logger.debug(JSON.stringify(link.failureDetails, null, 2));\n        }\n      }\n      core.setFailed(failureOutput);\n    }\n    core.setOutput('results', result);\n  } catch (err) {\n    core.setFailed(`Linkinator exception: \\n${err.message}\\n${err.stack}`);\n  }\n}\n\nfunction parseString (input) {\n  return core.getInput(input) || undefined;\n}\n\nfunction parseList (input) {\n  const value = core.getInput(input) || undefined;\n  if (value) {\n    return value.split(/[\\s,]+/).map(x => x.trim()).filter(x => !!x);\n  }\n  return undefined;\n}\n\nfunction parseNumber (input) {\n  const value = core.getInput(input) || undefined;\n  if (value) {\n    return Number(value);\n  }\n  return undefined;\n}\n\nfunction parseBoolean (input) {\n  const value = core.getInput(input) || undefined;\n  if (value) {\n    return Boolean(value);\n  }\n  return undefined;\n}\n\nfunction getVerbosity (verbosity) {\n  verbosity = verbosity.toUpperCase();\n  const options = Object.keys(LogLevel);\n  if (!options.includes(verbosity)) {\n    throw new Error(\n      `Invalid flag: VERBOSITY must be one of [${options.join(',')}]`\n    );\n  }\n  return LogLevel[verbosity];\n}\n\nconst LogLevel = {\n  DEBUG: 0,\n  INFO: 1,\n  WARNING: 2,\n  ERROR: 3,\n  NONE: 4\n};\n\nclass Logger {\n  constructor (level) {\n    this.level = level;\n  }\n\n  debug (message) {\n    if (this.level <= LogLevel.DEBUG) {\n      core.info(message);\n    }\n  }\n\n  info (message) {\n    if (this.level <= LogLevel.INFO) {\n      core.info(message);\n    }\n  }\n\n  warn (message) {\n    if (this.level <= LogLevel.WARNING) {\n      core.info(message);\n    }\n  }\n\n  error (message) {\n    if (this.level <= LogLevel.ERROR) {\n      core.error(message);\n    }\n  }\n}\n","\nimport { main } from './action.js';\nmain();\n"],"names":[],"sourceRoot":""}